{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Blog","text":"<p>Hi folks, my name is Matheus Cruz. I am a Software Engineer currently working at MercadoLibre, where I focus on enhancing our Fury (Internal Developer Platform) to improve documentation (Documentation Platform) and facilitate load testing (Performance Test Platform) for our developers. I am also an Open Source contributor, and I'm passionate about sharing knowledge!</p> <p>Talks:</p> <ul> <li>Getting Started with Extension Development on Quarkus [pt-BR]</li> </ul>"},{"location":"2024/01/17/deploying-a-quarkus-application-on-kubernetes/","title":"Deploying a Quarkus application on Kubernetes","text":""},{"location":"2024/01/17/deploying-a-quarkus-application-on-kubernetes/#tldr","title":"TL;DR","text":"<p>We will see how to deploy in detail a Quarkus application into a Kubernetes cluster.</p> <p>To achieve this goal, we will use:</p> <ul> <li>Quarkus CLI</li> <li>Kubernetes in Docker (KinD)</li> <li>Kubernetes</li> <li>NGINX Ingress Controller</li> </ul>"},{"location":"2024/01/17/deploying-a-quarkus-application-on-kubernetes/#quarkus-and-kubernetes","title":"Quarkus and Kubernetes","text":"<p>Usually, when people hear about Quarkus, they often think it's just a tool that speeds up the start of our application and consumes fewer computational resources. However, there's something very interesting as well: Quarkus is a Kubernetes-native framework with various extensions and functionalities that make working with Kubernetes easier.</p> <p>If you work with Kubernetes, managing multiple applications, and find yourself manually writing Kubernetes resources (such as Deployment, Service, ConfigMap, etc.) for each application, I would recommend using a tool like Helm, for instance. Now, if you are using Quarkus and desire even more convenience and a simpler way (with minimal manifest customization) without the need to worry about templates, etc., let me introduce you to the Quarkus Kubernetes extension.</p>"},{"location":"2024/01/17/deploying-a-quarkus-application-on-kubernetes/#kubernetes-extension","title":"Kubernetes Extension","text":"<p>The Kubernetes extension generates Kubernetes resources based on configurations. These configurations can be supplied by us (users) to generate the resources.</p> <p>It is possible to generate resources for OpenShift, vanilla Kubernetes, and Knative. You can create and customize <code>RBAC</code> resources, Ingress Controllers, Services, Deployments, etc. For more information, refer to the official documentation.</p> <p>GitOps</p> <p>This is a valuable feature of the GitOps approach. The Quarkus build can generate all the required resources, allowing configuration through environment variables (overriding <code>application.properties</code> values). These generated resources serve as input for GitOps tooling.</p>"},{"location":"2024/01/17/deploying-a-quarkus-application-on-kubernetes/#creating-the-kubernetes-cluster","title":"Creating the Kubernetes cluster","text":"<p>We will create a Kubernetes cluster with Kubernetes in Docker (KinD). As the name suggests, KinD aims to run a Kubernetes cluster inside Docker.</p> <p>Our Kubernetes cluster will have 1 control plane and 1 worker node!</p> Installing KinD <p>See here: How to install KinD with a package manager</p> <pre><code>cat &lt;&lt;EOF | kind create cluster --name dev --config=-\nkind: Cluster\napiVersion: kind.x-k8s.io/v1alpha4\nnodes:\n- role: control-plane\n  kubeadmConfigPatches:\n  - |\n    kind: InitConfiguration\n    nodeRegistration:\n      kubeletExtraArgs:\n        node-labels: \"ingress-ready=true\"\n  extraPortMappings:\n  - containerPort: 80\n    hostPort: 80\n    protocol: TCP\n  - containerPort: 443\n    hostPort: 443\n    protocol: TCP\n- role: worker\nEOF\n</code></pre> <p>An important note here is that we are labeling our nodes with <code>ingress-ready=true</code>. We will use the NGINX Ingress controller, and this labeling is necessary because NGINX only assigns pods to nodes that have this specific label.</p> <p>The KinD documentation says:</p> <ul> <li>extraPortMappings allow the local host to make requests to the Ingress controller over ports 80/443</li> <li>node-labels only allow the ingress controller to run on a specific node(s) matching the label selector</li> </ul> <p>After creating, we will install the NGINX Ingress Controller to expose internal Services.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/kind/deploy.yaml\n</code></pre>"},{"location":"2024/01/17/deploying-a-quarkus-application-on-kubernetes/#creating-the-quarkus-application","title":"Creating the Quarkus application","text":"<p>We will use Quarkus CLI to generate the application. See how to install Quarkus CLI here.</p> <p>Creating the Quarkus application with all necessary extensions:</p> <pre><code>quarkus create app dev.matheuscruz:quarkus-k8s --extension='quarkus-container-image-jib,quarkus-kind,resteasy-reactive'\n</code></pre> <ul> <li>The <code>quarkus-container-image-jib</code> extension assists in creating a container image using Jib.</li> <li>The <code>quarkus-kind</code> extension helps generate Kubernetes resources for vanilla Kubernetes and KinD.</li> <li>The <code>resteasy-reactive</code> extension helps create a REST service.</li> </ul> <p>Explore the Kubernetes resources generated by Quarkus:</p> <pre><code>quarkus build &amp;&amp; cat target/kubernetes/kubernetes.yml\n</code></pre> <p>The output should look something like this:</p> Output from cat command <pre><code>---\napiVersion: v1\nkind: Service\nmetadata:\n  annotations:\n    app.quarkus.io/build-timestamp: 2024-01-13 - 21:32:52 +0000\n  labels:\n    app.kubernetes.io/name: quarkus-k8s\n    app.kubernetes.io/version: 1.0.0-SNAPSHOT\n    app.kubernetes.io/managed-by: quarkus\n  name: quarkus-k8s\nspec:\n  ports:\n    - name: http\n      port: 80\n      protocol: TCP\n      targetPort: 8080\n  selector:\n    app.kubernetes.io/name: quarkus-k8s\n    app.kubernetes.io/version: 1.0.0-SNAPSHOT\n  type: ClusterIP\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  annotations:\n    app.quarkus.io/build-timestamp: 2024-01-13 - 21:32:52 +0000\n  labels:\n    app.kubernetes.io/name: quarkus-k8s\n    app.kubernetes.io/version: 1.0.0-SNAPSHOT\n    app.kubernetes.io/managed-by: quarkus\n  name: quarkus-k8s\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app.kubernetes.io/version: 1.0.0-SNAPSHOT\n      app.kubernetes.io/name: quarkus-k8s\n  template:\n    metadata:\n      annotations:\n        app.quarkus.io/build-timestamp: 2024-01-13 - 21:32:52 +0000\n      labels:\n        app.kubernetes.io/managed-by: quarkus\n        app.kubernetes.io/version: 1.0.0-SNAPSHOT\n        app.kubernetes.io/name: quarkus-k8s\n    spec:\n      containers:\n        - env:\n            - name: KUBERNETES_NAMESPACE\n              valueFrom:\n                fieldRef:\n                  fieldPath: metadata.namespace\n          image: cruz/quarkus-k8s:1.0.0-SNAPSHOT\n          imagePullPolicy: Always\n          name: quarkus-k8s\n          ports:\n            - containerPort: 8080\n              name: http\n              protocol: TCP\n</code></pre> <p>There are two points here. The first one is that <code>quarkus build</code> does not create the container image, and the container image is not correctly associated with my Docker Registry username, which is not <code>cruz</code>. This happens because, by default, the <code>quarkus-kubernetes</code> extension uses the system username if the Docker Registry username is not defined. The image was not created because we needed to instruct <code>quarkus build</code> to generate our container image.</p>"},{"location":"2024/01/17/deploying-a-quarkus-application-on-kubernetes/#configuring-our-build-and-container-image","title":"Configuring our build and container image","text":"<p>To meet our requirements for configuring the container image information and building the container image during <code>quarkus build</code>, Quarkus offers various configuration options. We will explore the most commonly used ones.</p> <pre><code>quarkus.kubernetes.namespace=default\nquarkus.container-image.build=true\nquarkus.container-image.group=matheuscruzdev\nquarkus.container-image.name=k6-with-quarkus\nquarkus.container-image.tag=1.0\n\n# Ingress Controller configs\nquarkus.kubernetes.ingress.expose=true\nquarkus.kubernetes.ingress.host=localhost\n</code></pre> <ol> <li>If you observe the generated resources, you will notice that no namespace is configured. To set the namespace of the resources, use the <code>quarkus.kubernetes.namespace</code> configuration to define the namespace.</li> <li>The <code>quarkus.container-image.build=true</code> configuration instructs the Quarkus CLI to generate the container image during the build.</li> <li>In line \"3,\" we are configuring the group of the container image, now, Quarkus will not get my system user.</li> <li>The property <code>quarkus.container-image.name</code> sets the container name.</li> <li>The property <code>quarkus.container-image.tag</code> sets the container image tag.</li> </ol> <p>The last two properties instruct Quarkus to generate an Ingress Controller and expose the application using it. The final property defines the value for <code>spec.rules[].host</code> in the IngressController.</p> <p>Applying all those properties into the <code>application.properties</code> and executing <code>quarkus build</code> again, we will get the following Ingress Controller definition:</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  annotations:\n    app.quarkus.io/build-timestamp: 2024-01-13 - 22:13:14 +0000\n  labels:\n    app.kubernetes.io/name: quarkus-k8s\n    app.kubernetes.io/version: 1.0.0-SNAPSHOT\n    app.kubernetes.io/managed-by: quarkus\n  name: quarkus-k8s\n  namespace: default\nspec:\n  rules:\n    - host: localhost\n      http:\n        paths:\n          - backend:\n              service:\n                name: quarkus-k8s\n                port:\n                  name: http\n            path: /\n            pathType: Prefix\n</code></pre> <p>As you can see, it generated an Ingress Controller pointing to our Service for us. It is very cool!</p> All generated resources <pre><code>  ---\n  apiVersion: v1\n  kind: Service\n  metadata:\n    annotations:\n      app.quarkus.io/build-timestamp: 2024-01-13 - 22:13:14 +0000\n    labels:\n      app.kubernetes.io/name: quarkus-k8s\n      app.kubernetes.io/version: 1.0.0-SNAPSHOT\n      app.kubernetes.io/managed-by: quarkus\n    name: quarkus-k8s\n    namespace: default\n  spec:\n    ports:\n      - name: http\n        port: 80\n        protocol: TCP\n        targetPort: 8080\n    selector:\n      app.kubernetes.io/name: quarkus-k8s\n      app.kubernetes.io/version: 1.0.0-SNAPSHOT\n    type: ClusterIP\n  ---\n  apiVersion: apps/v1\n  kind: Deployment\n  metadata:\n    annotations:\n      app.quarkus.io/build-timestamp: 2024-01-13 - 22:13:14 +0000\n    labels:\n      app.kubernetes.io/name: quarkus-k8s\n      app.kubernetes.io/version: 1.0.0-SNAPSHOT\n      app.kubernetes.io/managed-by: quarkus\n    name: quarkus-k8s\n    namespace: default\n  spec:\n    replicas: 1\n    selector:\n      matchLabels:\n        app.kubernetes.io/version: 1.0.0-SNAPSHOT\n        app.kubernetes.io/name: quarkus-k8s\n    template:\n      metadata:\n        annotations:\n          app.quarkus.io/build-timestamp: 2024-01-13 - 22:13:14 +0000\n        labels:\n          app.kubernetes.io/managed-by: quarkus\n          app.kubernetes.io/version: 1.0.0-SNAPSHOT\n          app.kubernetes.io/name: quarkus-k8s\n        namespace: default\n      spec:\n        containers:\n          - env:\n              - name: KUBERNETES_NAMESPACE\n                valueFrom:\n                  fieldRef:\n                    fieldPath: metadata.namespace\n            image: matheuscruzdev/quarkus-k8s:1.0\n            imagePullPolicy: Always\n            name: quarkus-k8s\n            ports:\n              - containerPort: 8080\n                name: http\n                protocol: TCP\n  ---\n  apiVersion: networking.k8s.io/v1\n  kind: Ingress\n  metadata:\n    annotations:\n      app.quarkus.io/build-timestamp: 2024-01-13 - 22:13:14 +0000\n    labels:\n      app.kubernetes.io/name: quarkus-k8s\n      app.kubernetes.io/version: 1.0.0-SNAPSHOT\n      app.kubernetes.io/managed-by: quarkus\n    name: quarkus-k8s\n    namespace: default\n  spec:\n    rules:\n      - host: localhost\n        http:\n          paths:\n            - backend:\n                service:\n                  name: quarkus-k8s\n                  port:\n                    name: http\n              path: /\n              pathType: Prefix\n</code></pre> <p>It is possible too see our container image locally:</p> <pre><code>docker images | grep quarkus-k8s\n\n# ... ommited\nmatheuscruzdev/quarkus-k8s 1.0 d02096d708c6 4 seconds ago 418MB\n</code></pre> GitOps Tip: Avoid Unnecessary deployments <p>As mentioned in this post, the Kubernetes extension is an excellent tool for the GitOps approach. If you observe the annotation <code>app.quarkus.io/build-timestamp</code>, you will find the timestamp indicating when this manifest was created. This can be an issue for the GitOps approach because tools recognize differences between manifests and apply a deployment strategy. See more details here on creating idempotent resources with the <code>quarkus.kubernetes.idempotent</code> property.</p>"},{"location":"2024/01/17/deploying-a-quarkus-application-on-kubernetes/#deploying-our-application","title":"Deploying our application","text":"<p>To deploy a Quarkus application into a Kubernetes cluster is very simple; we just need to execute <code>quarkus deploy</code>. Let's try it:</p> <pre><code>quarkus deploy\n</code></pre> <p>Seeing the Kubernetes objects:</p> <pre><code>kubectl get pods\n</code></pre> <p>If you see the output, we got an <code>ErrImagePull</code> error. This occurs because it was not possible to download the container image from the registry. It makes sense because we did not upload it before.</p> <p>Quarkus offers the possibility to push the image to a container registry using the following configurations:</p> <pre><code>quarkus.container-image.username=myusername\nquarkus.container-image.password=mypassword\nquarkus.container-image.registry=docker.io # used by default\n</code></pre> <p>I will use the docker push command to upload the container image to the Docker Registry. The command is <code>docker push &lt;docker-user&gt;/quarkus-k8s:1.0</code>.</p> Pushing to registry during build <p>If you want to push the image during build, you can use the following configurations:</p> <pre><code>quarkus.container-image.username=myusername\nquarkus.container-image.password=mypassword\nquarkus.container-image.registry=docker.io # used by default\n</code></pre> <p>Execute the build command:</p> <pre><code>quarkus build -Dquarkus.container-image.push=true\n</code></pre> <p>Now, if we execute the <code>quarkus deploy</code> command and access this endpoint... You will get this:</p> <pre><code>Hello from RESTEasy Reactive\n</code></pre> <p>Nice! We have a Quarkus application running into Kubernetes!  without to worry about Kubernetes manifests.</p>"},{"location":"2024/01/17/deploying-a-quarkus-application-on-kubernetes/#references-and-resources","title":"References and resources","text":"<ul> <li>Deploying to Kubernetes</li> <li>Container Images</li> </ul>"},{"location":"2024/01/17/deploying-a-quarkus-application-on-kubernetes/#source-code","title":"Source code","text":"<p>If you'd like to view the entire code, you can access it here.</p>"},{"location":"2024/01/17/deploying-a-quarkus-application-on-kubernetes/#thank-you","title":"Thank you","text":"<p>That's all; thank you for reading! See you in the next post. Goodbye! </p>"},{"location":"2024/01/12/developing-a-quarkus-extension/","title":"Developing a Quarkus Extension","text":""},{"location":"2024/01/12/developing-a-quarkus-extension/#tldr","title":"TL;DR","text":"<p>This post demonstrates how to create a Quarkus extension that provides three features that:</p> <ul> <li>Notify an API regarding the application's <code>starting</code> status;</li> <li>Offer a implementation class created with Gizmo;</li> <li>Count the number of methods using <code>@GET</code>, <code>@POST</code>, <code>@PUT</code>, <code>@DELETE</code> annotations using Jandex;  </li> </ul>"},{"location":"2024/01/12/developing-a-quarkus-extension/#why-quarkus-extension","title":"Why Quarkus extension?","text":"<p>Quarkus is both a framework and a build time augmentation toolkit. Its principal concept is \"do as much as possible during build time instead of runtime\", this concept is what helps Quarkus achieve a very low startup time and a smaller memory footprint.</p> <p>Quarkus enables the creation of a Native Image through Graal VM, making it an excellent choice for Serverless systems that require minimal startup time and memory usage.</p> <p>Additionally, Quarkus is a framework that has been captivating developers with its development experience. In the growth of internal developer platforms that aim for a developer-friendly experience, the experience that Quarkus provides is something to be considered.</p> <p>Keeping in mind these initial concepts, let's try to answer some questions:</p> <ul> <li> <p>Some libraries perform actions at runtime (class path scanning, proxies, etc.) instead of build time. How can we adapt them to the Quarkus closed world?</p> </li> <li> <p>Quarkus leverages the Graal SDK to generate a native application. However, it's essential to note that Graal VM does need some tweaks, and all executable code needs to be known before running. How can I adjust the code to be used as correct input for GraalVM?</p> </li> <li> <p>Managing an Internal Developer Platform with over 100+ Quarkus applications in production, I need to implement a specific cross-cutting approach across all applications. What is the recommended method to achieve this?</p> </li> </ul> <p>Commonly, the answer for all questions (when you are using Quarkus) is: Create a Quarkus extension.</p>"},{"location":"2024/01/12/developing-a-quarkus-extension/#quarkus-cli","title":"Quarkus CLI","text":"<p>The Quarkus CLI is an incredibly useful tool for working with Quarkus.</p> <p>There are several ways to install the Quarkus CLI. </p> Installing Quarkus CLI <p>Refer to the official documentation for installation instructions.</p> <p>With Quarkus CLI, we can <code>create</code>, <code>build</code>, <code>deploy</code> applications and perform essential tasks in a developer's day-to-day workflow. Be sure that you have it installed.</p>"},{"location":"2024/01/12/developing-a-quarkus-extension/#what-will-our-extension-do","title":"What will our extension do?","text":"<ul> <li>Notify an API regarding the application's <code>starting</code> status;</li> <li>Offer a simple implementation class with Gizmo;</li> <li>Count the number of methods using <code>@GET</code>, <code>@POST</code>, <code>@PUT</code>, <code>@DELETE</code> annotations using Jandex; </li> </ul> <p>Note</p> <p>All features are simple compared to real-world applications, but they serve as a great starting point to grasp and initiate your journey into the world of Quarkus extensions!</p>"},{"location":"2024/01/12/developing-a-quarkus-extension/#creating-the-extension","title":"Creating the extension","text":"<p>Once the Quarkus CLI is installed, we will use it to create our useful extension.</p> <pre><code>quarkus create extension dev.matheuscruz:quarkus-useful:0.0.1-SNAPSHOT\n</code></pre> <p>The desired output should be similar to:</p> <pre><code>Detected layout type is 'standalone' \nGenerated runtime artifactId is 'quarkus-useful'\n\n\napplying codestarts...\n\ud83d\udcda java\n\ud83d\udd28 maven\n\ud83d\udce6 quarkus-extension\n\ud83d\ude80 devmode-test\n\ud83d\ude80 extension-base\n\ud83d\ude80 integration-tests\n\ud83d\ude80 unit-test\n\n-----------\n \ud83d\udc4d  extension has been successfully generated in:\n--&gt; /home/cruz/github.com/mcruzdev/quarkus-useful\n-----------\nNavigate into this directory and get started: quarkus build\n</code></pre> <p>We are using the <code>standalone</code> layout, if you want to use the Quarkiverse layout execute the following command.</p> <pre><code>quarkus create extension io.quarkiverse:quarkus-useful:0.0.1-SNAPSHOT\n</code></pre>"},{"location":"2024/01/12/developing-a-quarkus-extension/#quarkus-extension-structure","title":"Quarkus extension structure","text":"<p>A Quarkus extension is divided in two modules, <code>deployment</code> and <code>runtime</code>.</p> <ul> <li> <p>The <code>deployment</code> module contains various components, such as build steps and build items, that play important roles in the application augmentation process.</p> </li> <li> <p>The <code>runtime</code> module contains runtime code that are used by <code>deployment</code> module at build time. </p> </li> </ul> <p>It might seem odd: Why is runtime code executed and utilized by build-time code?</p> <p>The reason is that runtime code is designed to be recorded for execution later. When you write this code, it's intended to be executed or used at a later stage.</p> <p>Note</p> <p>A <code>deployment</code> module must depend on the <code>runtime</code> module.</p>"},{"location":"2024/01/12/developing-a-quarkus-extension/#feature-1-implementing-the-notifier","title":"[Feature #1] Implementing the Notifier","text":"<p>What do we need here, and what is the expected behavior?</p> <p>We want that, when the application start we want to send a HTTP request to a specific endpoint, notifying that the application is starting.</p> <p>Use Quarkus Lifecycle instead</p> <p>This is merely a sample, demonstrating the capabilities of a Quarkus extension. Avoid using it in production scenarios. For a limited number of applications, consider utilizing the Quarkus Lifecycle feature instead.</p>"},{"location":"2024/01/12/developing-a-quarkus-extension/#creating-our-configuration","title":"Creating our configuration","text":"<p>To call a REST service, you'll require the resource's URI. How can you retrieve this information or determine what the URI is?</p> <p>We can do it into the code:</p> <pre><code>private static final String REST_ENDPOINT = \"https://api.quarkus.com/apps\"\n</code></pre> <p>But, it is not a good practice. Quarkus aims to facilitate the creation of Cloud Native applications, and a good Cloud Native application uses (when necessary) 12 Factors - Configuration approach.</p> <p>We need to make this configurable. I don't want to change the code and go through the entire release process (pull requests, approvals, pipelines, deployment, etc.) just to upload my extension with a new endpoint. To achieve this, Quarkus allows us to accomplish it using the Configuration feature. You simply need to create a POJO class and annotate it with <code>@io.quarkus.runtime.annotations.ConfigRoot</code>.</p> <pre><code>package dev.matheuscruz.quarkus.useful.runtime;\n\nimport java.util.Optional;\n\nimport io.quarkus.runtime.annotations.ConfigItem;\nimport io.quarkus.runtime.annotations.ConfigPhase;\nimport io.quarkus.runtime.annotations.ConfigRoot;\n\n@ConfigRoot(name = \"useful\", phase = ConfigPhase.BUILD_AND_RUN_TIME_FIXED)\npublic class UsefulConfiguration {\n\n    /**\n     * The listener URL to be notified about the 'starting' event of the\n     * application.\n     */\n    @ConfigItem(name = \"listenerUrl\")\n    public Optional&lt;String&gt; listenerUrl;\n}\n</code></pre> <p>Defining a proprety as Optional</p> <p>To define a configuration property as optional, you need to define the property as <code>Optional&lt;T&gt;</code>.</p> <ul> <li> <p>The element <code>name</code> means the configuration property name. At the final the properties inside the <code>UsefulConfiguration</code> will be the prefix <code>quarkus.useful</code>.</p> </li> <li> <p>The element <code>phase</code> indicates when this configuration will be visible.</p> </li> </ul> ConfigPhase enum <ul> <li><code>BUILD_TIME</code> - Values are read and available for usage at build time.</li> <li><code>BUILD_AND_RUNTIME_FIXED</code> - Values are read and available for usage at build time, and available on a read-only basis at run time.</li> <li><code>RUN_TIME</code> - Values are read and available for usage at run time and are re-read on each program execution.</li> </ul> <p>Perfect, now that we have the configuration available, let's use it.</p>"},{"location":"2024/01/12/developing-a-quarkus-extension/#calling-the-http-service","title":"Calling the HTTP service","text":"<p>As mentioned previously, all code that executes at runtime should be in the <code>runtime</code> module.</p> <p>Let's create the call to notify the <code>starting</code> event.</p> <pre><code>@Recorder // (3)\npublic class NotifyStartingEventRecorder {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(NotifyStartingEventRecorder.class);\n\n    public void notify(UsefulConfiguration config) { // (1)\n        if (config.listenerUrl.isEmpty()) {\n            LOGGER.warn(\n                    \"You are using the 'quarkus-useful' extension but the configuration property quarkus.useful.listenerUrl not defined\");\n            return;\n        }\n\n        String applicationName = ConfigProvider.getConfig() // (2)\n                .getConfigValue(\"quarkus.application.name\")\n                .getValue();\n\n        String body = String.format(\"{ \\\"applicationName\\\": \\\"%s\\\" }\", applicationName);\n        HttpRequest httpRequest = HttpRequest.newBuilder(URI.create(config.listenerUrl.get()))\n                .POST(BodyPublishers.ofString(body))\n                .build();\n\n        HttpClient httpClient = HttpClient.newHttpClient();\n\n        CompletableFuture&lt;HttpResponse&lt;String&gt;&gt; httpResponse = httpClient.sendAsync(httpRequest,\n                BodyHandlers.ofString());\n\n        httpResponse.thenAccept(t -&gt; {\n            LOGGER.info(\"The quarkus-useful-extension gets the HTTP status code: {}\", t.statusCode());\n        });\n    }\n}\n</code></pre> <ol> <li>Quarkus automagically injects the configuration POJO into the Recorder class.</li> <li>Quarkus uses Microprofile Config to access all provided configurations.</li> <li>The annotation <code>@Recorder</code> indicates that the given type is a recorder that is used to record actions to be executed at runtime.</li> </ol> <p>Perfectly, we have created our code that represents the code to be recorded. We will create now, the build step that will record this piece of code.</p>"},{"location":"2024/01/12/developing-a-quarkus-extension/#recording-the-notifyusefulconfiguration-config-method","title":"Recording the <code>notify(UsefulConfiguration config)</code> method","text":"<p>Now, we will create the class responsible for recording our runtime code.</p> <p>As mentioned previously all code related to the build process should be in <code>deployment</code> module. If you see into <code>deployment</code> module, there is a class called <code>QuarkusUsefulProcessor</code> (generated by Quarkus CLI):</p> <pre><code>package dev.matheuscruz.quarkus.useful.deployment;\n\nimport io.quarkus.deployment.annotations.BuildStep;\nimport io.quarkus.deployment.builditem.FeatureBuildItem;\n\nclass QuarkusUsefulProcessor {\n\n    private static final String FEATURE = \"quarkus-useful\";\n\n    @BuildStep\n    FeatureBuildItem feature() {\n        return new FeatureBuildItem(FEATURE);\n    }\n}\n</code></pre> <p>The Quarkus CLI generated a method with the <code>@BuildStep</code> annotation, indicating that this method is a step in the build process. Build step methods can produce or consume build items. In this case, it produces one build item called <code>FeatureBuildItem</code>.</p> <p>The <code>FeatureBuildItem</code> is used to include the feature (<code>quarkus-useful</code>) to be printed at startup, for example:</p> <pre><code>Installed features: [cdi, quarkus-useful, resteasy, smallrye-context-propagation, vertx]\n</code></pre>"},{"location":"2024/01/12/developing-a-quarkus-extension/#build-steps-and-build-items","title":"Build steps and build items","text":"<ul> <li> <p>Build steps are methods annotated with <code>@BuildStep</code> annotation that performs a step in the build process;</p> </li> <li> <p>Build items are:</p> <p>... the communication mechanism between build steps - Holly Cummins </p> </li> <li> <p>Quarkus automatically determines correctly execution order and injects parameters (<code>BuildItem</code>, <code>BuildProducer</code>, configuration classes, etc.);</p> </li> <li> <p>If you intend to utilize a build item through injection, remember that your build step will execute after the injected build item is produced;</p> </li> <li> <p>There are initial, intermediate, and terminal state build steps. Custom extensions are commonly found in the intermediate state.</p> </li> </ul>"},{"location":"2024/01/12/developing-a-quarkus-extension/#creating-the-build-step","title":"Creating the build step","text":"<p>Let's create the method in the <code>QuarkusUsefulProcessor</code> class that will handle recording our notifier.</p> <pre><code>@BuildStep\n@Record(value = ExecutionTime.RUNTIME_INIT)\nvoid recordNotifyStartingEventRecorder(UsefulConfiguration config,\n        NotifyStartingEventRecorder recorder) {\n    // the following call will be recorded\n    recorder.notify(config);\n}\n</code></pre> <p>What does the <code>@Record</code> annotation mean, and what is the value <code>ExecutionTime.RUNTIME_INIT</code>?</p> <p>The <code>ExecutionTime</code> enum has two options: <code>RUNTIME_INIT</code> and <code>STATIC_INIT</code>.</p> <p>Let's dive into some simple code examples to understand how these choices impact bytecode.</p> <pre><code>public class GeneratedBytecode {\n\n  static {\n    // @Record(value = ExecutionTime.STATIC_INIT)\n    // All code recorded with STATIC_INIT will be here.\n  }\n\n  public static void main(String args[]) {\n    // @Record(value = ExecutionTime.RUNTIME_INIT)\n    // All code recorded with RUNTIME_INIT will be here.\n  }\n}\n</code></pre> See more: How to see the generated bytecode <p>If you want to see the bytecode generated, into extension root dir runs:</p> <ul> <li><code>mvn clean install</code></li> <li>cd <code>integration-tests</code></li> <li><code>mvn clean package -DskipTests -Dquarkus.package.vineflower.enabled=true</code></li> <li><code>cat target/decompiled/generated-bytecode/io/quarkus/runner/ApplicationImpl.java</code></li> </ul> <p>You will see that in the method <code>doStart(String[] var1)</code> there is a piece of code like it: <code>(new QuarkusUsefulProcessor$recordNotifyStartingEventRecorder1857232657()).deploy(var2);</code></p> <p>The option <code>quarkus.package.vineflower.enabled=true</code> tell to Quarkus decompile generated and transformed bytecode into the 'decompiled' directory. </p> <p>Perfect, if you want to test the notifier, execute:</p> <pre><code>mvn clean install\n\ncd integration-tests\n\nquarkus dev\n</code></pre> <p>The output should looks like:</p> <pre><code>2024-01-06 19:17:34,449 WARN  [dev.mat.qua.use.run.NotifyStartingEventRecorder] (Quarkus Main Thread) You are using the 'quarkus-useful' extension but the configuration property quarkus.useful.listenerUrl not defined\n</code></pre> <p>It happened because we forgot to set the <code>quarkus.useful.listenerUrl</code> property into <code>application.properties</code> file. Add the configuration property to <code>application.properties</code> and observe the result.</p> Mocking HTTP request <pre><code>Use https://app.beeceptor.com/ this service to mock the HTTP request.\n</code></pre> <p>Now, that we have configured the <code>quarkus.useful.listenerUrl</code>, the output should looks like it: </p> <pre><code>2024-01-12 20:44:00,303 INFO  [io.quarkus] (main) quarkus-useful-integration-tests 0.0.1-SNAPSHOT on JVM (powered by Quarkus 3.6.5) started in 0.980s. Listening on: http://0.0.0.0:8080\n2024-01-12 20:44:00,304 INFO  [io.quarkus] (main) Profile prod activated. \n2024-01-12 20:44:00,304 INFO  [io.quarkus] (main) Installed features: [cdi, quarkus-useful, resteasy, smallrye-context-propagation, vertx]\n2024-01-12 20:44:01,107 INFO  [dev.mat.qua.use.run.NotifyStartingEventRecorder] (ForkJoinPool.commonPool-worker-1) The quarkus-useful-extension gets the HTTP status code: 200\n</code></pre>"},{"location":"2024/01/12/developing-a-quarkus-extension/#feature-2-implementing-our-greetingservice-interface","title":"[Feature #2] Implementing our GreetingService interface","text":"<p>In some scenarios, offering a default implementation to our extension consumers becomes necessary, as seen in great libraries. </p> <p>Essentially, in our case the user will inject a <code>GreetingService</code> interface, and the extension will provide a default implementation behind the scenes (using Gizmo ).</p> <p>The interface:</p> <pre><code>public interface GreetingService {\n  String message();\n}\n</code></pre> <p>The user's code:</p> <pre><code>@Path(\"/greetings\")\npublic class GreetingResource {\n\n  GreetingService service;\n\n  // Injected by ArC dependency injection  \n  public GreetingResource(GreetingService service) {\n    this.service = service;\n  }\n\n  @GET\n  @Produces(MediaType.TEXT_PLAIN)\n  public String greeting() {\n    return service.message();\n  }\n}\n</code></pre> <p>There are several ways to achieve this with Quarkus. One approach is implementing the interface and providing it by using CDI directly. However, let's get hands-on with Gizmo to get our initial experience with this tooling. </p>"},{"location":"2024/01/12/developing-a-quarkus-extension/#gizmo","title":"Gizmo","text":"<p>Gizmo is a library used by Quarkus to generate bytecode. If you are interested, there is an amazing video by the Quarkus Core team that explains the library in a better way. You can watch it here. We will provide a simple implementation with Gizmo, but is it possible do more interesting things with this library, like removing a bytecode to solve a specific problem.</p>"},{"location":"2024/01/12/developing-a-quarkus-extension/#creating-the-greetingservice","title":"Creating the GreetingService","text":"<p>Into the <code>runtime</code> module, let's create our interface:</p> <pre><code>package dev.matheuscruz.quarkus.useful.runtime;\n\npublic interface GreetingService {\n    String message();\n}\n</code></pre>"},{"location":"2024/01/12/developing-a-quarkus-extension/#creating-the-implementation","title":"Creating the implementation","text":"<p>Into the <code>deployment</code> module, let's create a new build step to generate our implementation.</p> <pre><code>@BuildStep\nvoid generateGreetingService(BuildProducer&lt;GeneratedBeanBuildItem&gt; generatedClasses) {\n}\n</code></pre> <p>@Record is not necessary</p> <p>The <code>@Record</code> annotation isn't always mandatory. Sometimes, annotating the method solely with <code>@BuildStep</code> suffices to include it in the augmentation process. However, if you have the <code>@Record</code> annotation you need to have a <code>@Recorder</code> class injected in the method.</p> <p>There are two ways to generate a Build Item, the first one is returning the Build Item in method, and the second one is using the class <code>BuildProducer&lt;T extends BuildItem&gt;</code>.</p> <p>Let's continue with the implementation:</p> <pre><code>@BuildStep\nvoid generateGreetingService(BuildProducer&lt;GeneratedBeanBuildItem&gt; generatedClasses) {\n      GeneratedBeanGizmoAdaptor gizmoAdapter = new GeneratedBeanGizmoAdaptor(generatedClasses);\n    try (ClassCreator classCreator = ClassCreator.builder()\n            .className(\"dev.matheuscruz.quarkus.useful.deployment.UsefulGreetingService\")\n            .interfaces(GreetingService.class)\n            .classOutput(gizmoAdapter)\n            .build()) {\n\n        classCreator.addAnnotation(ApplicationScoped.class);\n\n        try (MethodCreator returnHello = classCreator.getMethodCreator(\"message\",\n                String.class)) {\n            returnHello.setModifiers(Opcodes.ACC_PUBLIC);\n            returnHello.returnValue(returnHello.load(\"Hello from Quarkus Useful extension\"));\n        }\n    }\n}\n</code></pre> <p>What this build step does ind depth? Let's see:</p> <ol> <li> <p>The <code>GeneratedBeanBuildItem</code> is a build item having the bytecode that will be added as CDI bean (after in the augmentation process).</p> </li> <li> <p>The line \"3\"  is an adapter that uses the <code>BuildProducer&lt;GeneratedBeanBuildItem&gt;</code> injected into <code>generateGreetingService</code> method.</p> </li> <li> <p>The line \"6\" we are indicating that the new class will implements the <code>GreetingService</code> interface.</p> </li> <li> <p>In the line \"10\" we are adding the annotation <code>jakarta.ws.rs.ApplicationPath</code> to the new class.</p> </li> <li> <p>The <code>ClassCreator</code> is the class responsible for generating the bytecode, the instance of <code>GeneratedBeanGizmoAdaptor</code> is used as <code>ClassCreator.classOutput</code> property.</p> </li> <li> <p>When the method <code>ClassCreator#close()</code> is called the <code>ClassCreator</code> writes the bytecode inside de <code>GeneratedBeanGizmoAdaptor</code> instance. Note that we are using <code>try-with-resources</code>.</p> </li> <li> <p>Behind the scenes the <code>GeneratedBeanGizmoAdaptor</code> uses the <code>BuildProducer&lt;GeneratedBeanBuildItem&gt;</code> instance to produces the a <code>GeneratedBeanBuildItem</code> instance.</p> </li> </ol> See more: ClassCreator#close() implementation <pre><code>public void close() {\n    final ClassOutput classOutput = this.classOutput;\n    if (classOutput != null) {\n        writeTo(classOutput);\n    }\n}\n</code></pre> See more: GeneratedBeanGizmoAdaptor#write() implementation <pre><code>    @Override\npublic void write(String className, byte[] bytes) {\n    String source = null;\n    if (sources != null) {\n        StringWriter sw = sources.get(className);\n        if (sw != null) {\n            source = sw.toString();\n        }\n    }\n    classOutput.produce(new GeneratedBeanBuildItem(className, bytes, source));\n}\n</code></pre>"},{"location":"2024/01/12/developing-a-quarkus-extension/#using-our-hidden-greetingservice-implementation","title":"Using our hidden GreetingService implementation","text":"<p>Now, that we have the default implementation, let's use our <code>integration-tests</code> module to test it.</p> <p>We need now to create a new resource called <code>GreetingResource</code>, to test our implementation:</p> <pre><code>package dev.matheuscruz.quarkus.useful.it;\n\nimport dev.matheuscruz.quarkus.useful.runtime.GreetingService;\nimport jakarta.inject.Inject;\nimport jakarta.ws.rs.GET;\nimport jakarta.ws.rs.Path;\n\n@Path(\"/greetings\")\npublic class GreetingResource {\n\n    @Inject\n    GreetingService greetingService;\n\n    @GET\n    public String greeting() {\n        return greetingService.message();\n    }\n}\n</code></pre> <p>Install the extension:</p> <pre><code>mvn clean install\n</code></pre> <p>Go to the <code>integration-tests</code> module directory (<code>cd integration-tests</code>) and execute:</p> <pre><code>quarkus dev\n</code></pre> <p>Open the browser and access the resource.</p> <p>The output should shows: <code>Hello from Quarkus Useful extension</code>.</p>"},{"location":"2024/01/12/developing-a-quarkus-extension/#feature-3-counting-the-number-of-crud-methods","title":"[Feature #3] Counting the number of CRUD methods","text":"<p>This feature helps us find and log methods annotated with <code>@POST</code>, <code>@GET</code>, <code>@PUT</code>, and <code>@DELETE</code> using Jandex. To log information at runtime, it's necessary to create a <code>Recorder</code> class within the <code>runtime</code> module.</p>"},{"location":"2024/01/12/developing-a-quarkus-extension/#jandex","title":"Jandex","text":"<p>Jandex is a powerful Java annotation indexer and library that allows developers to efficiently analyze and index Java classes. It's particularly useful for Quarkus to perform annotation-based processing during build time. </p>"},{"location":"2024/01/12/developing-a-quarkus-extension/#consolerecorder","title":"ConsoleRecorder","text":"<p>Just as we did with our notifier in the first feature, let's create the code that will be recorded to be executed at runtime.</p> <pre><code>@Recorder\npublic class ConsoleRecorder {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(ConsoleRecorder.class);\n\n    public void log(List&lt;String&gt; logs) {\n        for (String l : logs) {\n            LOGGER.info(l);\n        }\n    }\n}\n</code></pre>"},{"location":"2024/01/12/developing-a-quarkus-extension/#creating-the-deployment-code","title":"Creating the deployment code","text":"<p>Quarkus offers two build items (<code>ApplicationIndexBuildItem</code>, <code>CombinedIndexBuildItem</code>) that enable us to obtain an index for accessing annotations, implementations, interfaces, and more. In the <code>ApplicationIndexBuildItem</code> we have all application classes and in the <code>CombinedIndexBuildItem</code> we have all the application classes and all relevant classes from dependencies, etc.</p> <pre><code>private static final DotName POST_DOT_NAME = DotName.createSimple(\"jakarta.ws.rs.POST\");\nprivate static final DotName GET_DOT_NAME = DotName.createSimple(\"jakarta.ws.rs.GET\");\nprivate static final DotName PUT_DOT_NAME = DotName.createSimple(\"jakarta.ws.rs.PUT\");\nprivate static final DotName DELETE_DOT_NAME = DotName.createSimple(\"jakarta.ws.rs.DELETE\");\n\n@BuildStep\n@Record(value = ExecutionTime.STATIC_INIT)\nvoid countJaxRs(ApplicationIndexBuildItem jandex, ConsoleRecorder consoleRecorder) {\n    Index index = jandex.getIndex();        \n    List&lt;String&gt; logs = List.of(POST_DOT_NAME, GET_DOT_NAME, PUT_DOT_NAME, DELETE_DOT_NAME)\n            .stream()\n            .map(dotName -&gt; {\n                int size = index.getAnnotations(dotName).size();\n                LOGGER.info(\"This is called during build time\");\n                return String.format(\"Your application has %d method(s) annotated with %s\", size,\n                        dotName.toString());\n            })\n            .collect(Collectors.toList());\n\n    // The following code is recorded to be runned at runtime.\n    consoleRecorder.log(logs);\n}\n</code></pre> <ul> <li>In lines \"1-4\", DotName instances are defined to represent JaxRS annotations within our codebase.</li> <li>At line \"7\", we specify that the recorded code will be executed within the static block.</li> <li>At line \"8\", Quarkus injects the <code>ApplicationIndexBuildItem</code> build item into our build step.</li> <li>On line \"13\", we utilize the Jandex index to discover all annotations within the application.</li> <li>On line \"21\", a List of messages is passed to our Recorder class method for use."},{"location":"2024/01/12/developing-a-quarkus-extension/#testing-our-extension-feature","title":"Testing our extension feature","text":"<p>Let's add a new method inside the <code>QuarkusUsefulResource</code>:</p> <pre><code>@POST\npublic void log() {\n    return \"log was called\";\n}\n</code></pre> <p>Now, we have two methods annotated with <code>@GET</code> annotation, and one annotatated with <code>@POST</code> annotation.</p> <p>Let's build the extension:</p> <pre><code>mvn clean install\n</code></pre> <p>Go to the <code>integration-tests</code>:</p> <pre><code>cd integration-tests\n</code></pre> <p>Execute the application:</p> <pre><code>quarkus dev\n</code></pre> <p>The log should looks like it:</p> <pre><code>2024-01-12 20:08:28,985 INFO  [dev.mat.qua.use.run.ConsoleRecorder] (Quarkus Main Thread) Your application has 1 method(s) annotated with jakarta.ws.rs.POST\n2024-01-12 20:08:28,985 INFO  [dev.mat.qua.use.run.ConsoleRecorder] (Quarkus Main Thread) Your application has 2 method(s) annotated with jakarta.ws.rs.GET\n2024-01-12 20:08:28,985 INFO  [dev.mat.qua.use.run.ConsoleRecorder] (Quarkus Main Thread) Your application has 0 method(s) annotated with jakarta.ws.rs.PUT\n2024-01-12 20:08:28,985 INFO  [dev.mat.qua.use.run.ConsoleRecorder] (Quarkus Main Thread) Your application has 0 method(s) annotated with jakarta.ws.rs.DELETE\n</code></pre>"},{"location":"2024/01/12/developing-a-quarkus-extension/#references-and-resources","title":"References and resources","text":"<p>This provides a concise overview of the Quarkus extension. For in-depth information, refer to the comprehensive official resources dedicated to this subject:</p> <ul> <li>Quarkus in Action</li> <li>Writing Extensions</li> <li>Building My First Extension</li> <li>Writing Native Applications Tips</li> <li>Quarkus Insights #43: Writing Quarkus Extensions - Peter Palaga</li> <li>Why you're missing out if you're not making Quarkus extensions by Holly Cummins Georgios Andrianakis</li> <li>Quarkus Insights #52: Gizmo: Build-time Boost Your Extensions - Martin Kouba</li> </ul>"},{"location":"2024/01/12/developing-a-quarkus-extension/#source-code","title":"Source code","text":"<p>If you'd like to view the entire code, you can access it here.</p>"},{"location":"2024/01/12/developing-a-quarkus-extension/#thank-you","title":"Thank you","text":"<p>That's all; thank you for reading! See you in the next post. Goodbye! </p>"},{"location":"2024/01/22/quarkus-devservices-with-jnosql/","title":"Quarkus DevServices with JNoSQL","text":"<p>In this post, we will get an introduction to JNoSQL and Quarkus DevServices, two great tools that facilitate our lives as developers.</p> <p>We will implement a simple DevService feature for <code>quarkus-jnosql</code> project. Basically, if you change to a CouchDB database the extension will provide a CouchDB container for you, if you change to a ArangoDB database the extension will provide a ArangoDB container for you!</p> <p>With this post, you will be able to understand how Quarkus DevService works and get started with Quarkus extension contribution. Why not?</p>"},{"location":"2024/01/22/quarkus-devservices-with-jnosql/#jnosql","title":"JNoSQL","text":"<p>Recently, in the Java world, the JakartaOne event took place in Portuguese. In this event, Max Arruda talked about JNoSQL. In a simple way, in my humble opinion, I can summarize: JNoSQL is the Strategy pattern but for switching database implementations. What does it mean? For example, if you are using a key-value database like Redis and you want to change to another key-value database like ArangoDB, you just need to add the implementation (ArangoDB), make a simple configuration change, and voil\u00e0, you are now using ArangoDB to persist all the necessary data.</p>"},{"location":"2024/01/22/quarkus-devservices-with-jnosql/#quarkus-devservices","title":"Quarkus DevServices","text":"<p>If you are using Quarkus, you already know about the developer experience that Quarkus provides. DevServices is just the same thing: it increases the developer experience when you are coding a Quarkus application. Basically, if your application needs to access a database or send a message to Kafka, Quarkus provides it through <code>application.properties</code> configurations. It is an amazing experience because you do not have to worry about accessing the Kafka Docker website, obtaining the necessary configuration to start the Kafka container.</p> <p>It utilizes the TestContainers project behind the scenes to set up all the required infrastructure for testing and development mode.</p>"},{"location":"2024/01/22/quarkus-devservices-with-jnosql/#knowing-the-quarkus-jnosql-project","title":"Knowing the quarkus-jnosql project","text":"<p>Let's think that you want to use the Quarkus JNoSQL extension with ArangoDB implementation, to do it, you need to create a Quarkus application and add the following dependency into your <code>pom.xml</code>, it is very simple, looks:</p> Creating a Quarkus application <p>If you have Quarkus CLI executes: <code>quarkus create app</code>, if not access https://code.quarkus.io and create your Quarkus application.</p> <pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;io.quarkiverse.jnosql&lt;/groupId&gt;\n  &lt;artifactId&gt;quarkus-jnosql-document-arangodb&lt;/artifactId&gt;\n  &lt;version&gt;3.2.2.2&lt;/version&gt;\n&lt;/dependency&gt;\n\n&lt;dependency&gt;\n  &lt;groupId&gt;org.eclipse.jnosql.databases&lt;/groupId&gt; \n  &lt;artifactId&gt;jnosql-arangodb&lt;/artifactId&gt;\n  &lt;version&gt;1.0.4&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>And, to configure the <code>application.properties</code> file:</p> <pre><code>jnosql.document.database=arangodb\njnosql.arangodb.host=localhost:8529\njnosql.arangodb.password=openSesame\n</code></pre> <p>And, to execute the container image containing ArangoDB database:</p> <pre><code>docker run -p 8529:8529 -e ARANGO_ROOT_PASSWORD=openSesame arangodb/arangodb:3.11.6\n</code></pre> <p>Ok, it is relatevily simple, no? But, we can dot it more simple with DevServices.</p>"},{"location":"2024/01/22/quarkus-devservices-with-jnosql/#code-implementation","title":"Code implementation","text":"<p>Our API will have a simple <code>Developer</code> entity and a simple resource. Below, you can see the <code>Developer</code> entity:</p> <pre><code>package dev.matheuscruz;\n\nimport java.util.Objects;\nimport jakarta.nosql.Id;\nimport jakarta.nosql.Column;\nimport jakarta.nosql.Entity;\n\n@Entity\npublic class Developer {\n\n    @Id\n    String id;\n\n    @Column\n    String name;\n\n    @Column\n    String github;\n\n    public Developer() {\n    }\n\n    public Developer(String name, String github) {\n        this.name = Objects.requireNonNullElse(name, \"anonymous\");\n        this.github = Objects.requireNonNullElse(github, \"https://github.com/anonymous\");\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getGithub() {\n        return github;\n    }\n}\n</code></pre> <p>The Resource:</p> <pre><code>package dev.matheuscruz;\n\nimport java.net.URI;\nimport java.util.List;\nimport jakarta.inject.Inject;\nimport jakarta.nosql.document.DocumentTemplate;\nimport jakarta.ws.rs.GET;\nimport jakarta.ws.rs.POST;\nimport jakarta.ws.rs.Path;\nimport jakarta.ws.rs.core.Response;\n\n@Path(\"/devs\")\npublic class DeveloperResource {\n\n    @Inject\n    DocumentTemplate template;\n\n    @POST\n    public Response create(DevRequest request) {\n\n        Developer dev = new Developer(request.name, request.github);\n        Developer newDev = template.insert(dev);\n        return Response.created(URI.create(\"/devs/\" + newDev.getId())).build();\n    }\n\n    @GET\n    public Response all() {\n        List&lt;Developer&gt; all = template.select(Developer.class).result();\n        return Response.ok(all).build();\n    }\n\n    record DevRequest(String name, String github) {\n    }\n}\n</code></pre> <p>If you access the API endoint through the following <code>cURL</code>, you will create a <code>Developer</code>.</p> <pre><code>curl --request POST \\\n  --url http://localhost:8080/devs \\\n  --header 'Content-Type: application/json' \\\n  --header 'User-Agent: insomnia/8.5.1' \\\n  --data '{\n    \"name\": \"Matheus Cruz\",\n    \"github\": \"https://github.com/mcruzdev\"\n}'\n</code></pre> <p>To get all users, execute the following <code>cURL</code> command:</p> <pre><code>curl --request GET \\\n  --url http://localhost:8080/devs \\\n  --header 'User-Agent: insomnia/8.5.1'\n</code></pre> <p>You can see something like this:</p> <pre><code>[\n    {\n        \"id\": \"Developer/179\",\n        \"name\": \"Matheus Cruz\",\n        \"github\": \"https://github.com/mcruzdev\"\n    }\n]\n</code></pre> <p>Done, we are using Quarkus JNoSQL with ArangoDB, and for now, the idea here is not to change the implementation (classes, etc.). We want to keep the codebase intact. If we decide to change the database, it is necessary only to modify the <code>pom.xml</code> (dependencies) and the <code>application.properties</code> file (configurations).</p>"},{"location":"2024/01/22/quarkus-devservices-with-jnosql/#getting-started-with-devservices","title":"Getting Started with DevServices","text":"<p>If you saw the last section, it was necessary to execute a Docker container with some configurations, right? A Quarkus extension is not just to provide build-time augmentation; it is meant to offer a better developer experience for extension users.</p> <p>Let's offer for our extension users a way to provide the container when they change the <code>jnosql.document.database</code> property.</p> <p>Info</p> <p>The goal here is to demonstrate how Quarkus DevServices works in practice. It does not reflect a real-world implementation but can serve as a starting point for you. We will implement DevServices for both ArangoDB Document and CouchDB Document.</p> <p>We will divide this in 3 steps:</p> <ol> <li>Look at the <code>jnosql.document.database</code> to determine which database we are using.</li> <li>Read the configuration property (only the necessary to run the container) for each database type. This is necessary because a database configuration differs from another one.</li> <li>Start a container for ArangoDB or CouchDB if necessary.</li> </ol>"},{"location":"2024/01/22/quarkus-devservices-with-jnosql/#1-reading-the-jnosqldocumentdatabase-property","title":"1. Reading the jnosql.document.database property","text":"<p>Developing a Quarkus extension</p> <p>If you are not familiar with Quarkus extensions, I recommend checking out my first post on this subject.</p> <p>Having the <code>quarkus-jnosql</code> fork, let's create the class responsible for DevService:</p> <pre><code>package io.quarkiverse.jnosql.document.deployment;\n\nimport io.quarkus.deployment.annotations.BuildStep;\nimport org.eclipse.microprofile.config.ConfigProvider;\n\npublic class DocumentDevServices {\n    @BuildStep\n    public void build() {\n    }\n}\n</code></pre> <p>There are some ways to read the <code>application.properties</code>, to do it we will use the <code>ConfigProvider</code> class:</p> <pre><code>@BuildStep\npublic void build() {\n\n    Set&lt;String&gt; allowedDatabases = Set.of(\"arangodb\", \"couchdb\"); // (1)\n    String database = ConfigProvider.getConfig()\n            .getOptionalValue(\"jnosql.document.database\", String.class)\n            .orElse(\"\"); // (2)\n    if (!allowedDatabases.contains(database)) {\n        LOGGER.warn(\"This extensions does provide support only for [arangodb, couchdb] document databases\");\n        return;\n    }\n}\n</code></pre> <ol> <li>We are configuring all allowed databases;</li> <li>We are using <code>ConfigProvider.getConfig()</code> method to get the <code>jnosql.document.database</code> value;</li> </ol>"},{"location":"2024/01/22/quarkus-devservices-with-jnosql/#2-reading-specific-database-configuration","title":"2. Reading specific database configuration","text":"<p>The goal here is to obtain only the necessary configuration to run the container with the application. </p> <p>For the ArangoDB container, the minimal configuration to execute the container is <code>docker run -p 8529:8529 -e ARANGO_ROOT_PASSWORD=openSesame arangodb/arangodb:3.11.6</code>, mapping to jnosql configuration, we need:</p> <pre><code>jnosql.document.database=arangodb\njnosql.arangodb.host=localhost:8529\njnosql.arangodb.password=openSesame\n</code></pre> <p>For the CouchDB container, the minimal configuration to execute the container is <code>docker run -e COUCHDB_PASSWORD=password -e COUCHDB_USER=admin -p 5984:5984 couchdb</code>, mapping to jnosql configuration, we need:</p> <pre><code>jnosql.document.database=couchdb\njnosql.couchdb.port=5984\njnosql.couchdb.host=localhost\njnosql.couchdb.password=password\njnosql.couchdb.username=admin\n</code></pre>"},{"location":"2024/01/22/quarkus-devservices-with-jnosql/#3-start-a-container","title":"3. Start a container ...","text":"<p>To use TestContainers we need to add the dependency in <code>pom.xml</code>:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.testcontainers&lt;/groupId&gt;\n    &lt;artifactId&gt;testcontainers&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre> <p>The TestContainer library provides a class that allows us to run and control a container. This class is called <code>GenericContainer&lt;T&gt;</code>. We need to create two classes that extend <code>GenericContainer&lt;T&gt;</code>, where we will include the necessary code to configure the container.</p>"},{"location":"2024/01/22/quarkus-devservices-with-jnosql/#couchdbcontainer","title":"CouchDBContainer","text":"<pre><code>    // ... ommited\n    static class CouchDBContainer extends GenericContainer&lt;CouchDBContainer&gt; {\n        public static final Integer COUCHDB_DEFAULT_PORT = 5984;\n        public CouchDBContainer() {\n            super(DockerImageName.parse(\"couchdb:latest\")); // (1)\n        }\n    }\n</code></pre> <ol> <li>We are defining the image name</li> </ol>"},{"location":"2024/01/22/quarkus-devservices-with-jnosql/#arangodbcontainer","title":"ArangoDBContainer","text":"<pre><code>    // ommited\n    static class ArangoDBContainer extends GenericContainer&lt;ArangoDBContainer&gt; {\n        public static final Integer ARANGO_DB_DEFAULT_PORT = 8529;\n        public ArangoDBContainer() {\n            super(DockerImageName.parse(\"arangodb:latest\")); // (1)\n        }\n    }\n</code></pre> <ol> <li>We are defining the image name</li> </ol> <p>Now, let's use those class into our <code>@BuildStep</code> method.</p> <pre><code>@BuildStep(onlyIfNot = { IsNormal.class }, onlyIf = { GlobalDevServicesConfig.Enabled.class })\npublic void build(BuildProducer&lt;DevServicesResultBuildItem&gt; devServicesProducer) {\n\n    Set&lt;String&gt; allowedDatabases = Set.of(\"arangodb\", \"couchdb\");\n    String database = ConfigProvider.getConfig()\n            .getOptionalValue(\"jnosql.document.database\", String.class)\n            .orElse(\"\");\n    if (!allowedDatabases.contains(database)) {\n        LOGGER.warn(\"This extensions does provide support only for [arangodb, couchdb] document databases\");\n        return;\n    }\n\n    LOGGER.info(\"jnosql.document.database === {}\", database);\n\n    if (database.equals(\"couchdb\")) {\n\n        Integer bindPort = ConfigProvider.getConfig().getValue(\"jnosql.couchdb.port\", Integer.class);\n        String password = ConfigProvider.getConfig().getValue(\"jnosql.couchdb.password\", String.class);\n        String username = ConfigProvider.getConfig().getValue(\"jnosql.couchdb.username\", String.class);\n\n        CouchDBContainer couchDBContainer = new CouchDBContainer()\n                .withEnv(\n                        Map.of(\"COUCHDB_PASSWORD\", password,\n                                \"COUCHDB_USER\", username))\n                .withExposedPorts(CouchDBContainer.COUCHDB_DEFAULT_PORT);\n\n        couchDBContainer.setPortBindings(\n                List.of(String.format(\"0.0.0.0:%d:%d\", CouchDBContainer.COUCHDB_DEFAULT_PORT, bindPort)));\n\n        couchDBContainer.start();\n\n        LOGGER.info(couchDBContainer.getLogs());\n\n        devServicesProducer.produce(new DevServicesResultBuildItem.RunningDevService(\n                \"jnosql-document\",\n                couchDBContainer.getContainerId(),\n                couchDBContainer::close,\n                Map.of()).toBuildItem());\n    } else {\n        String host = ConfigProvider.getConfig().getValue(\"jnosql.arangodb.host\", String.class);\n        String[] hostPort = host.split(\":\");\n        Integer bindPort = Integer.valueOf(hostPort[1]);\n\n        String password = ConfigProvider.getConfig().getValue(\"jnosql.arangodb.password\", String.class);\n\n        ArangoDBContainer arangoDBContainer = new ArangoDBContainer()\n                .withExposedPorts(ArangoDBContainer.ARANGO_DB_DEFAULT_PORT)\n                .withEnv(\"ARANGO_ROOT_PASSWORD\", password);\n\n        arangoDBContainer.setPortBindings(\n                List.of(String.format(\"0.0.0.0:%d:%d\", ArangoDBContainer.ARANGO_DB_DEFAULT_PORT, bindPort)));\n\n        arangoDBContainer.start();\n\n        LOGGER.info(arangoDBContainer.getLogs());\n\n        devServicesProducer.produce(new DevServicesResultBuildItem.RunningDevService(\n                \"jnosql-document\",\n                arangoDBContainer.getContainerId(),\n                arangoDBContainer::close,\n                Map.of()).toBuildItem());\n    }\n}\n\nstatic class ArangoDBContainer extends GenericContainer&lt;ArangoDBContainer&gt; {\n    public static final Integer ARANGO_DB_DEFAULT_PORT = 8529;\n\n    public ArangoDBContainer() {\n        super(DockerImageName.parse(\"arangodb:latest\"));\n    }\n}\n\nstatic class CouchDBContainer extends GenericContainer&lt;CouchDBContainer&gt; {\n    public static final Integer COUCHDB_DEFAULT_PORT = 5984;\n\n    public CouchDBContainer() {\n        super(DockerImageName.parse(\"couchdb:latest\"));\n    }\n}\n</code></pre> <p>Disclaimer</p> <p>All the code provided here is crafted to streamline the utilization of TestContainer. In a real-world scenario, it is essential to consider and adhere to best practices in coding.</p> <ul> <li> <p>In line 1 we are defining that this <code>@BuildStep</code> method will be called if the <code>BooleanSupplier</code> <code>IsNormal.class</code> resolves to false (<code>onlyIfNot = { IsNormal.class }</code>) and if the <code>quarkus.devservices.enabled</code> (<code>onlyIf = { GlobalDevServicesConfig.Enabled.class }</code>) value is true. This is necessary because DevServices only run in <code>Test</code> and <code>Dev</code> modes and in our scenario if Quarkus DevServices is enabled.</p> </li> <li> <p>At line 5, we are retrieving the value of the <code>jnosql.document.database</code> property to obtain the database name to be used later.</p> </li> <li>In lines 17-19 we are reading the specific configuration for CouchDB.</li> <li>At line 30 we are starting the container.</li> <li>In lines 34-38, we are using the <code>BuildProducer&lt;DevServicesResultBuildItem&gt;</code> instance to produce a <code>DevServicesResultBuildItem</code> build item, which will be utilized later by Quarkus. Note that we are using the <code>CouchDBContainer::close</code> <code>Closeable</code> reference in the <code>BuildStep</code>. This is very useful for Quarkus, as it allows us to \"close\" the container when the <code>Test</code> or <code>Dev</code> mode is finished.</li> </ul> <p>The same thing is made for ArangoDB database.</p>"},{"location":"2024/01/22/quarkus-devservices-with-jnosql/#testing-devservices","title":"Testing DevServices","text":"<p>After changing the <code>quarkus-jnosql</code> project, we will install it locally. Go to the <code>quarkus-jnosql</code> directory and execute:</p> <pre><code>mvn clean install\n</code></pre> <p>You need now, to install it in your Quarkus project using a <code>SNAPSHOT</code> version. Today, in my case the latest version is <code>3.2.2.2-SNAPSHOT</code>, add the following dependency into your Quarkus project. We will test the CouchDB first.</p> <pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;io.quarkiverse.jnosql&lt;/groupId&gt;\n  &lt;artifactId&gt;quarkus-jnosql-document-couchdb&lt;/artifactId&gt;\n  &lt;version&gt;3.2.2.2-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Now, if you change the <code>jnosql.document.database</code> property value to <code>couchdb</code> you will get a container running in your local development or test.</p>"},{"location":"2024/01/22/quarkus-devservices-with-jnosql/#testing-couchdb","title":"Testing CouchDB","text":"<p>Necessay dependencies:</p> <pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;io.quarkiverse.jnosql&lt;/groupId&gt;\n  &lt;artifactId&gt;quarkus-jnosql-document-couchdb&lt;/artifactId&gt;\n  &lt;version&gt;3.2.2.2-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n\n&lt;dependency&gt;\n  &lt;groupId&gt;org.eclipse.jnosql.databases&lt;/groupId&gt;\n  &lt;artifactId&gt;jnosql-couchdb&lt;/artifactId&gt;\n  &lt;version&gt;1.0.4&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Necessary configurations:</p> <pre><code>jnosql.document.database=couchdb\njnosql.couchdb.port=5984\njnosql.couchdb.host=localhost\njnosql.couchdb.password=password\njnosql.couchdb.username=admin\n\nquarkus.devservices.enabled=true\n</code></pre> <p>Running <code>quarkus dev</code> and using the API, you can see that the application works well!</p> Request to create dev <pre><code>curl --request POST \\\n  --url http://localhost:8080/devs \\\n  --header 'Content-Type: application/json' \\\n  --header 'User-Agent: insomnia/8.5.1' \\\n  --data '{\n  \"name\": \"Matheus Cruz\",\n  \"github\": \"https://github.com/mcruzdev\"\n}'\n</code></pre> Request to get all devs <pre><code>  curl --request GET \\\n  --url http://localhost:8080/devs \\\n  --header 'User-Agent: insomnia/8.5.1'\n</code></pre> <p>Result after creating a dev and getting all:</p> <pre><code>[\n    {\n        \"id\": \"3ff80981-925b-43f6-bcce-65a86469400a\",\n        \"name\": \"Matheus Cruz\",\n        \"github\": \"https://github.com/mcruzdev\"\n    }\n]\n</code></pre>"},{"location":"2024/01/22/quarkus-devservices-with-jnosql/#chaning-to-arangodb","title":"Chaning to ArangoDB","text":"<p>Necessary dependencies:</p> <p>Note</p> <p>Remove the CouchDB dependencies first.</p> <pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;io.quarkiverse.jnosql&lt;/groupId&gt;\n  &lt;artifactId&gt;quarkus-jnosql-document-arangodb&lt;/artifactId&gt;\n  &lt;version&gt;3.2.2.2-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n\n&lt;dependency&gt;\n  &lt;groupId&gt;org.eclipse.jnosql.databases&lt;/groupId&gt;\n  &lt;artifactId&gt;jnosql-arangodb&lt;/artifactId&gt;\n  &lt;version&gt;1.0.4&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Necessary properties:</p> <pre><code>jnosql.document.database=arangodb\njnosql.arangodb.host=localhost:8529\njnosql.arangodb.password=openSesame\n</code></pre> <p>Result after creating a dev and getting all:</p> <pre><code>[\n    {\n        \"id\": \"Developer/170\",\n        \"name\": \"Matheus Cruz\",\n        \"github\": \"https://github.com/mcruzdev\"\n    }\n]\n</code></pre>"},{"location":"2024/01/22/quarkus-devservices-with-jnosql/#references","title":"References","text":"<ul> <li>DevServices Overview</li> </ul>"},{"location":"2024/01/22/quarkus-devservices-with-jnosql/#source-code","title":"Source code","text":"<p>The source code from this post can be reached here (JNoSQL fork) and here(Quarkus Application that uses Quarkus JNoSQL fork)!</p>"},{"location":"2024/01/22/quarkus-devservices-with-jnosql/#thank-you","title":"Thank you","text":"<p>That's all; thank you for reading! See you in the next post. Goodbye! </p>"},{"location":"2024/01/30/outbox-pattern-in-quarkus/","title":"Outbox pattern in Quarkus","text":"<p>If you need to save data into two different systems, such as persist a data in the database and then notify another service about the local changes (through RabbitMQ, Kafka, ActiveMQ, etc.), this post is for you!</p> <p>In this post, we will explore how to solve dual writes problem in a distributed systems using Quarkus.</p>"},{"location":"2024/01/30/outbox-pattern-in-quarkus/#scenario","title":"Scenario","text":"<p>Imagine you have an order system, and every time an order is created or its status is changed, you need to notify another system to perform an action. This scenario is common when working with microservices. In the microservice world, each microservice needs to be cohesive, have low coupling, and be deployable independently. With these principles in mind, the only way to communicate with another microservice is through the network, which often leads to an increase in dual writes. Dual writes involve writing data into two different systems simultaneously. For example, writing into the database and also writing into ActiveMQ.</p> <p>In the upcoming sections, we will see this in action and look at some common mistakes people make when trying to fix the dual writes issue.</p>"},{"location":"2024/01/30/outbox-pattern-in-quarkus/#doing-it-with-a-monolith","title":"Doing it with a monolith","text":"<p>In a monolith, it is very simple because most of the time we have just one write operation, where we are writing into one system (commonly database). Basically, what we need is:</p> <p>I can do all things in a single transaction, right?</p> <pre><code>public CreateOrderOutput execute(final CreateOrderInput input) {\n    Order order = new Order(); // 1. Create the order\n\n    // Create another domain object from the Order instance // (1)\n\n    QuarkusTransaction.requiringNew().run(() -&gt; {\n        // 2. Persist the `order`;\n        // 3. Save the order details in the database for reporting purposes;\n    })\n\n    return new CreateOrderOutput(order);\n}\n</code></pre> <ol> <li>This other object, in a microservice architecture, would probably be in another microservice.</li> </ol> <p>Either everything happens, or nothing does\u2014atomicity at work. Working with a monolith is straightforward; you don't have to concern yourself with the complexities of distributed transactions that often arise in microservices architectures. In a monolithic system, everything is contained within a single codebase, making it easier to manage transactions and ensure consistency across the application. </p> <p>Note</p> <p>It does not mean that a monolith cannot perform dual writes; sometimes, a monolith needs to publish an event to write to another system as well.</p>"},{"location":"2024/01/30/outbox-pattern-in-quarkus/#doing-it-with-microservices","title":"Doing it with Microservices","text":"<p>Let's consider a scenario with two microservices: order-service and report-service. The order-service receives an HTTP request, saves the order, and it's necessary to notify the report-service when the order is created/updated. We will see, with code samples, some mistakes that occur when we try to achieve this goal.</p>"},{"location":"2024/01/30/outbox-pattern-in-quarkus/#code-1","title":"Code 1","text":"<pre><code>public CreateOrderOutput execute(CreateOrderInput input) {\n\n    Order order = input.createOrder();\n\n    publisher.send(new OrderCreatedEvent(order));\n\n    QuarkusTransaction.requiringNew().run(() -&gt; {\n        orderRepository.save(order);\n    });\n\n    return new CreateOrderOutput(order);\n}\n</code></pre> <p>It's incredible! We are utilizing a queue, using an event-driven architecture woooow!</p> <p>What is the problem here? tic! tac! </p> <p>Answer: We are publishing to the queue first, if the database fails the report-service will get a incosistent data.</p>"},{"location":"2024/01/30/outbox-pattern-in-quarkus/#code-2","title":"Code 2","text":"<p>Alright, now I do everything in a single transaction: first, I try to save it in the database, then I send it to the queue. If the queue fails, I don't save it in the database.</p> <pre><code>public CreateOrderOutput execute(CreateOrderInput input) {\n\n    Order order = input.createOrder();\n\n    QuarkusTransaction.requiringNew().run(() -&gt; {\n        orderRepository.save(order);\n        publisher.send(new OrderCreatedEvent(order));\n    });\n\n    return new CreateOrderOutput(order);\n}\n</code></pre> <p>What is the problem here? tic! tac! tic! tac!  </p> <p>Answer: We are adding I/O operation into a database transaction, it is a wrong decision and bad practice.</p> Do not execute I/O operation into the transaction <p>The problem with putting I/O operations inside a transaction is that it can cause locking and increase waiting time since transactions typically lock resources until they are completed. Additionally, some I/O operations may not be transactional by nature, which can lead to unexpected behaviors or partially completed transactions in case of failure. Instead, it is generally preferable to perform I/O operations outside the transaction or in a separate transaction, depending on the specific requirements of the system.</p>"},{"location":"2024/01/30/outbox-pattern-in-quarkus/#code-3","title":"Code 3","text":"<p>Ok, I will try again...</p> <pre><code>public CreateOrderOutput execute(CreateOrderInput input) {\n\n    Order order = input.createOrder();\n\n    QuarkusTransaction.requiringNew().run(() -&gt; {\n        orderRepository.save(order);\n    });\n\n    publisher.send(new OrderCreatedEvent(order));\n\n    return new CreateOrderOutput(order);\n}\n</code></pre> <p>What is the problem here? tic! tac! tic! tac! tic! tac!  </p> <p>Answer: The problem here is that the publishing of the event can fail. If it fails, the report-service will not be notified.</p>"},{"location":"2024/01/30/outbox-pattern-in-quarkus/#solving-with-outbox-pattern","title":"Solving with Outbox Pattern","text":"<p>When we perform dual writes, such as saving order data and sending a message to the queue, it's challenging to maintain consistency.</p> <p>In our situation, we are trying to save order data and send a message at the same time. To solve this, we need another task that keeps trying until both actions are done.</p> <p>This other task, which will keep retrying until both actions are done, can be implemented using the Outbox pattern. The Outbox pattern can be composed with two operations:</p> <ol> <li>Save both the order and the message in the database. If the message is sent successfully to the queue, delete it from the database. If not, move to step 2.</li> <li>Retry sending the message to the queue. We can do this thanks step 1.</li> </ol> <p>Show me the code!</p> <pre><code>public CreateOrderOutput execute(CreateOrderInput input) {\n\n    Order order = input.createOrder();\n\n    OrderCreatedEvent event = new OrderCreatedEvent(\n            order.getId(),\n            order.getStatus().name(),\n            order.getCreatedAt());\n\n    Outbox outbox = new Outbox(eventToMessage(event)); // (1)\n\n    QuarkusTransaction.requiringNew().run(() -&gt; { // (2)\n        this.orderRepository.persist(order);\n        this.outboxRepository.persist(outbox);\n    });\n\n    this.publisher.send(event); // (3)\n\n    QuarkusTransaction.requiringNew().run(() -&gt; {\n        this.outboxRepository.deleteById(outbox.getId()); // (4)\n    });\n\n    return Response.created(URI.create(\"/orders/\" + order.getId())).build();\n}\n</code></pre> <ol> <li>We are creating the <code>Outbox</code> instance using the <code>OrderCreatedEvent</code> object. Here, we will save the <code>OrderCreatedEvent</code> serialized.</li> <li>We are saving both the <code>Order</code> and the <code>Outbox</code> within the transaction. This is necessary because I need to ensure that both are saved together.</li> <li>We are publishing the <code>OrderCreatedEvent</code> to the queue.</li> <li>if the publisher.send(event) works well, We will delete the <code>Outbox</code> record.</li> </ol> <p>With this approach, we can ensure that we will not lose the <code>OrderCreatedEvent</code> event if the publishing step fails. If the publishing step fails, we have the <code>OrderCreatedEvent</code> message stored in the database through the <code>Outbox</code>. However, it is not complete yet we need to do the step 2 - we have the event in the database, but we need to retry it because the report-service needs to be notified.</p>"},{"location":"2024/01/30/outbox-pattern-in-quarkus/#retry-retry-retry","title":"Retry, retry, retry","text":"<p>Below, you can find a code sample where we are attempting to resend the message to the queue.</p> <pre><code>@Scheduled(every = \"5s\") // (1)\nvoid retry() {\n    List&lt;Outbox&gt; outboxs = this.outboxRepository.listAll();\n    for (Outbox outbox : outboxs) { // (2)\n        this.publisher.send(outbox.getMessage());\n        QuarkusTransaction.requiringNew().run(() -&gt; { // (3)\n            this.outboxRepository.delete(outbox.getId());\n        });\n    }\n}\n</code></pre> <ol> <li>We are using Quarkus <code>scheduler</code> for scheduling periodic tasks.</li> <li>For each <code>Outbox</code> entry, we are sending it to the queue and storing the result.</li> <li>We are deleting all <code>Outbox</code> entries that have been sent within a single transaction.</li> </ol> Info <p>Adapt the code to fit your needs. Running it <code>every 5 seconds</code> is ideal for testing the Outbox retry functionality.</p> <p>Important</p> <p>Note that our consumer (report-service) needs to be idempotent because there's a chance that the order-service might send the same message multiple times. Another crucial point to remember is that if I try to send an OrderCreatedEvent message and encounter an error, and then shortly after, the status of my order changes to CANCELED, there's a possibility that I might send the CANCELED event before the order created event.</p>"},{"location":"2024/01/30/outbox-pattern-in-quarkus/#considerations","title":"Considerations","text":"<p>In this post, you've seen how to implement the Outbox pattern. Another method for addressing the dual write issue is by utilizing Change Data Capture (CDC). You can read more about CDC here.</p>"},{"location":"2024/01/30/outbox-pattern-in-quarkus/#source-code","title":"Source code","text":"<p>I used the following technologies in the repository:</p> <ul> <li>Panache</li> <li>PostgreSQL</li> <li>DevServices</li> <li>Scheduler</li> </ul> <p>If you'd like to view the entire code, you can access it here.</p>"},{"location":"2024/01/30/outbox-pattern-in-quarkus/#thank-you","title":"Thank you","text":"<p>That's all; thank you for reading! See you in the next post. Goodbye! \ud83d\udc4b</p>"},{"location":"2024/12/07/improve-developer-joy-and-productivity-with-quarkus-and-dapr/","title":"Improve developer joy and productivity with Quarkus and Dapr","text":""},{"location":"2024/12/07/improve-developer-joy-and-productivity-with-quarkus-and-dapr/#tldr","title":"TL;DR","text":"<p>If you are already using Quarkus, you are likely familiar with the incredible developer experience it offers through features such as DevServices, DevUI, and live reload. You probably appreciate how these features enhance your experience.</p> <p>Now, imagine taking that developer joy to the next level when building complex distributed cloud native applications by integrating it with the productivity and standardization provided by Dapr. While Quarkus optimizes the experience for the development process of a single application, Dapr focuses more on providing best practices and well-known patterns to help developers to build distributed applications.</p> <p>In this blog post, we will explore what Dapr is and how to use it in combination with the Quarkus framework.</p>"},{"location":"2024/12/07/improve-developer-joy-and-productivity-with-quarkus-and-dapr/#what-is-dapr","title":"What is Dapr?","text":"<p>Dapr stands for Distributed Application Runtime:</p> <p>Dapr is a portable, event-driven runtime that makes it easy for any developer to build resilient, stateless, and stateful applications that run on the cloud and edge and embraces the diversity of languages and developer frameworks.</p> <p>In my opinion, what makes Dapr truly remarkable is the abstraction layer and standardization it provides in the shape of building blocks when integrated into your architecture.</p>"},{"location":"2024/12/07/improve-developer-joy-and-productivity-with-quarkus-and-dapr/#dapr-building-blocks","title":"Dapr Building Blocks","text":"<p>So, what are Dapr building blocks? Essentially, building blocks are APIs accessed over the network through HTTP or gRPC calls. In this post, I will discuss in details only two building blocks, including: Publish and Subscribe, State Management.</p> <p></p> About the diagram <p>The diagram above illustrates what we will implement in the following sections, using an in-memory State Store and Pub/Sub for simplicity. However, Dapr is not limited to these options and supports a wide range of state stores and messaging systems.</p> <p>Remember when I mentioned abstraction layer?</p> <p>When you use the State Management building block, you are interacting with the Dapr runtime to store or retrieve data from a data store. This state store can be AWS DynamoDB, Azure CosmosDB, Redis, Cassandra, Firebase, and more.</p> <p>The same principle applies to Publish and Subscribe. You interact with the Dapr API, and Dapr takes care of communication with the message broker on your behalf. You can take a look at all the PubSub supported implementations here.</p> <p>Dapr also provides other useful building blocks:</p> <ul> <li>Service Invocation: Perform resilient (retries and circuit breakers), secure (mtls), service-to-service method calls.</li> <li>Workflow: Orchestrate logic across various microservices</li> <li>State management: Create long running stateful services by persisting and retrieving data</li> <li>Bindings: Integrate reliably with or be triggered from external systems</li> <li>Actors: Encapsulate code and data in reusable actor objects as a common microservices design pattern</li> <li>Secrets management: Securely access secrets from your application</li> <li>Configuration: Manage and be notified of application configuration changes</li> <li>Distributed lock: Distributed locks provide mutually exclusive access to shared resources from an application. No need to add new libraries to your application or new components in the infrastructure.</li> <li>Cryptography: Perform cryptographic operations without exposing keys to your application</li> <li>Jobs: Manage the scheduling and orchestration of jobs</li> </ul> <p>Ufa!</p> <p>How do you configure all these abstractions and integration points? Let\u2019s look at Dapr Components.</p>"},{"location":"2024/12/07/improve-developer-joy-and-productivity-with-quarkus-and-dapr/#dapr-components","title":"Dapr Components","text":"<p>Components serve as configurations for building blocks and applications. With components, you can define specific behaviors and characteristics when utilizing a building block.</p> <p>If you're an experienced developer, you might be asking: Do I need to configure retries, dead letter queues, and resilience features if I don't have the Kafka API library to set up?</p> <p>Getting Pub/Sub building block (using Kafka) as example, you can define routes to your topic:</p> <pre><code>apiVersion: dapr.io/v2alpha1\nkind: Subscription\nmetadata:\n  name: myevent-subscription\nspec:\n  type: pubsub.kafka\n  pubsubname: pubsub\n  topic: inventory\n  routes:\n    rules:\n      - match: event.type == \"widget\"\n        path: /widgets\n      - match: event.type == \"gadget\"\n        path: /gadgets\n    default: /products\nscopes:\n  - app1\n  - app2\n</code></pre> <p>Getting State management as example, you can enable transaction outbox pattern, using the component specification:</p> <pre><code>apiVersion: dapr.io/v1alpha1\nkind: Component\nmetadata:\n  name: mysql-outbox\nspec:\n  type: state.mysql\n  version: v1\n  metadata:\n    - name: connectionString\n      value: \"&lt;CONNECTION STRING&gt;\"\n    - name: outboxPublishPubsub # required\n      value: \"mypubsub\"\n    - name: outboxPublishTopic # required\n      value: \"newOrder\"\n    - name: outboxPubsub # optional\n      value: \"myOutboxPubsub\"\n    - name: outboxDiscardWhenMissingState # optional, defaults to false\n      value: false\n</code></pre> <p>There are a bunch of configurations and Component types, to see a more detailed view, see the official documentation for each building block.</p>"},{"location":"2024/12/07/improve-developer-joy-and-productivity-with-quarkus-and-dapr/#what-is-quarkus","title":"What is Quarkus?","text":"<p>Quarkus is a modern, open-source Java framework designed for building cloud-native applications. It optimizes Java specifically for Kubernetes and the cloud, providing a powerful solution for developing microservices and serverless applications.</p> <p>There are some benefits, I will list what makes sense for me actually:</p> <ul> <li> <p>Native Compilation: Quarkus prepare and allows you to generate a native image for you Operational System, without the need to have a JVM running.</p> </li> <li> <p>Live Reload: When I am working with another frameworks and languages, I need to <code>run</code> &gt; <code>change</code> &gt; <code>stop</code> and <code>run</code>... in a loop. With Live reload I am happy, the feedback loop is very fast.</p> </li> <li> <p>Developer Joy: With DevService and DevUI our life as developer is amazing, we do not nee more to access the Docker image documentation for a database, to copy and pase a <code>docker-compose.yml</code> file from a project to another... You just need to add an extension with DevService and your infrastructure is ready to use.</p> </li> <li> <p>Subatomic and Supersonic: Thanks to Quarkus's mission, uses significantly less resources (CPU/Memory) than traditional approaches.</p> </li> </ul> <p>If you want to see more benefits about Quarkus, see the official documentation.</p>"},{"location":"2024/12/07/improve-developer-joy-and-productivity-with-quarkus-and-dapr/#creating-you-quarkus-application-with-dapr","title":"Creating you Quarkus application with Dapr","text":"<p>Let's create our Quarkus application with Quarkus CLI.</p> <pre><code>quarkus create app dev.matheuscruz:try-dapr -x=io.quarkiverse.dapr:quarkus-dapr\n</code></pre> <p>The previous command creates a Quarkus application with <code>\u00eco.quarkiverse.dapr:quarkus-dapr</code> extension.</p>"},{"location":"2024/12/07/improve-developer-joy-and-productivity-with-quarkus-and-dapr/#running-the-application","title":"Running the application","text":"<p>Before configuring the DevService for running Dapr, let's run our Quarkus application:</p> <pre><code>quarkus dev\n</code></pre> <p>The previous command runs the Quarkus application in dev mode.</p> <p>By default, the <code>quarkus.dapr.devservices.enabled</code> is set to false. This property indicates wether the DevService for Dapr extension is enabled or not. Let's enable!</p>"},{"location":"2024/12/07/improve-developer-joy-and-productivity-with-quarkus-and-dapr/#configuring-the-application","title":"Configuring the application","text":"<p>Using your browser access the DevUI Configuration. You will filter by <code>quarkus.dapr.devservice.enabled</code> and check the checkbox.</p> <p></p> <p>Looking the changes</p> <p>If you look the <code>application.properties</code> file, you will se the changes made by DevUI configuration page.</p> <p>After this simple change, if you access your terminal and type <code>docker ps</code>you will se that you have a container image running.</p> <pre><code>docker ps\nCONTAINER ID  IMAGE                                COMMAND               CREATED        STATUS        PORTS                                                                   NAMES\n\n7e32f9223bd9  docker.io/testcontainers/sshd:1.2.0  echo ${USERNAME}:...  2 minutes ago  Up 2 minutes  0.0.0.0:38461-&gt;22/tcp, 22/tcp                                           blissful_solomon\n2dd0127159a8  docker.io/daprio/daprd:latest        ./daprd -app-id l...  2 minutes ago  Up 2 minutes  0.0.0.0:33613-&gt;3500/tcp, 0.0.0.0:42571-&gt;50001/tcp, 3500/tcp, 50001/tcp  focused_fermi\n</code></pre> <p>The <code>daprio/daprd</code> container is the Dapr sidecar, configured by the Dapr DevService.</p> Behind the scenes <p>Behind the scnes the Quarkus Dapr extension uses TestContainer API to create a container with the following command.</p> <pre><code>withCommand(\n            \"./daprd\",\n            \"-app-id\", appName,\n            \"--dapr-listen-addresses=0.0.0.0\",\n            \"--app-protocol\", \"http\",\n            \"-placement-host-address\", placementService + \":50006\",\n            \"--app-channel-address\", appChannelAddress,\n            \"--app-port\", Integer.toString(appPort),\n            \"--log-level\", daprLogLevel.toString(),\n            \"-components-path\", \"/components\");\n</code></pre> <p>See the <code>daprd</code> reference here.</p>"},{"location":"2024/12/07/improve-developer-joy-and-productivity-with-quarkus-and-dapr/#using-pubsub","title":"Using Pub/Sub","text":"<p>Now, we have all necessary things to use Dapr with Quarkus - We have a Dapr Sidecar container running and our Quarkus application running/listening changes.</p> <p>We will create a <code>ProductResource</code> responsible for publishing message through <code>SyncDaprClient</code>.</p> <pre><code>package dev.matheuscruz.product;\n\nimport io.quarkiverse.dapr.core.SyncDaprClient;\nimport jakarta.inject.Inject;\nimport jakarta.ws.rs.POST;\nimport jakarta.ws.rs.Path;\nimport jakarta.ws.rs.core.Response;\n\nimport java.util.List;\nimport java.util.Random;\n\n@Path(\"/products\")\npublic class ProductResource {\n\n    static final String DEV_SERVICE_PUBSUBE_NAME = \"pubsub\"; // (2)\n\n    @Inject\n    SyncDaprClient syncDaprClient; // (1)\n\n    @POST\n    public Response create() {\n        List&lt;String&gt; products = List.of(\"mouse\", \"gpu\", \"cpu\");\n        int random = new Random().nextInt(products.size());\n        syncDaprClient.publishEvent(DEV_SERVICE_PUBSUBE_NAME, \"products.new\", // (3)\n         products.get(random));  // (4)\n        return Response.accepted().build();\n    }\n}\n</code></pre> <ol> <li>The Dapr client API responsible for perform calls to Dapr Sidecar.</li> <li>The Pub/Sub component name, by default Quarkus Dapr extension creates a Pub/Sub component with <code>pubsub</code>name.</li> <li>The topic name.</li> <li>The message that will be sent.</li> </ol> <p>By default, Quarkus Dapr extension uses a in-memory Pub/Sub and State Store components, but you can declare it through <code>src/main/resources/components</code> folder.</p>"},{"location":"2024/12/07/improve-developer-joy-and-productivity-with-quarkus-and-dapr/#consuming-events","title":"Consuming events","text":"<p>To make our demostration more simple, let's consume the event sent in the same application.</p> <pre><code>package dev.matheuscruz.product;\n\nimport io.dapr.Topic;\nimport io.dapr.client.domain.CloudEvent;\nimport jakarta.enterprise.context.ApplicationScoped;\nimport jakarta.ws.rs.POST;\nimport jakarta.ws.rs.Path;\n\n\n@Path(\"/handlers\")\n@ApplicationScoped\npublic class ProductCreatedHandler {\n\n    @POST\n    @Topic(name = \"products.new\", pubsubName = \"pubsub\") // click (1) to see more\n    @Path(\"/products\") // (2)\n    public void handle(CloudEvent&lt;String&gt; event) {\n        System.out.println(\"Received: \" + event.getData());\n    }\n}\n</code></pre> <ol> <li> <p>The <code>@Topic</code>annotation is responsible for mapping an endpoint to a topic, the <code>@Topic#name</code> is the name of the topic and the <code>@Topic#pubsubName</code> is the name of the Pub/Sub component.</p> </li> <li> <p>This is just to get your topic mapped, you can set any string on <code>@Path#value</code>, it can be <code>banana</code> if you want.</p> </li> </ol>"},{"location":"2024/12/07/improve-developer-joy-and-productivity-with-quarkus-and-dapr/#testing-the-pubsub","title":"Testing the Pub/Sub","text":"<p>If we make a request to <code>/products</code>:</p> <pre><code>curl -X POST http://localhost:8080/products\n</code></pre> <p>We can see the following log in our application:</p> <pre><code>Received: ...\n</code></pre>"},{"location":"2024/12/07/improve-developer-joy-and-productivity-with-quarkus-and-dapr/#using-state-management","title":"Using State Management","text":"<p>Let's change our <code>ProductCreatedHandler</code> to use State Management building block.</p> <pre><code>package dev.matheuscruz.product;\n\nimport io.dapr.Topic;\nimport io.dapr.client.domain.CloudEvent;\nimport io.dapr.client.domain.State;\nimport io.dapr.utils.TypeRef;\nimport io.quarkiverse.dapr.core.SyncDaprClient;\nimport jakarta.enterprise.context.ApplicationScoped;\nimport jakarta.inject.Inject;\nimport jakarta.ws.rs.POST;\nimport jakarta.ws.rs.Path;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.UUID;\n\n@Path(\"/handlers\")\n@ApplicationScoped\npublic class ProductCreatedHandler {\n\n\n    @Inject\n    SyncDaprClient syncDaprClient;\n\n    @POST\n    @Topic(name = \"products.new\", pubsubName = \"pubsub\")\n    @Path(\"/products\")\n    public void handle(CloudEvent&lt;String&gt; event) {\n        System.out.println(\"Received: \" + event.getData());\n        try {\n            State&lt;Product&gt; state = syncDaprClient.getState(\"kvstore\",// (1)\n            event.getData(), TypeRef.get(Product.class));\n            System.out.println(\"We already have a product with name: \" + state.getValue());\n        } catch (Exception e) {\n            System.out.println(\"We do not have a product :(\");\n            // Let's create\n            syncDaprClient.saveState(\"kvstore\", event.getData(), new Product(\n                    event.getData()\n            )); // (2)\n        }\n    }\n\n    public record Product(String name) {}\n}\n</code></pre> <ol> <li> <p>Trying to get the product, the <code>kvstore</code> is the state store component name created by Quakus Dapr extension, this is a in-memory state store.</p> </li> <li> <p>Using Dapr client to save a product.</p> </li> </ol>"},{"location":"2024/12/07/improve-developer-joy-and-productivity-with-quarkus-and-dapr/#testing-the-state-store","title":"Testing the state store","text":"<p>If we make some requests to <code>/products</code> endpoint:</p> <pre><code>curl -X POST http://localhost:8080/products\n</code></pre> <p>We can see the following log in our application:</p> <pre><code>Received: book\nWe do not have a product :(\nReceived: mouse\nWe do not book a product :(\nReceived: cpu\nWe already have a product with name: Product[name=book]\nReceived: book\nWe already have a product with name: Product[name=book]\n</code></pre>"},{"location":"2024/12/07/improve-developer-joy-and-productivity-with-quarkus-and-dapr/#post-summary","title":"Post Summary","text":"<p>In this post, we explored how to combine Quarkus and Dapr to enhance the developer experience when building distributed and cloud-native applications. We started by reviewing what Dapr is\u2014a portable, event-driven runtime that provides building blocks like State Management and Pub/Sub, offering abstraction and standardization to simplify integrations with databases, message brokers, and other services.</p> <p>We also discussed Quarkus, a modern Java framework optimized for the cloud and Kubernetes, highlighting its benefits such as native compilation, live reload, and DevServices. We demonstrated how to create a Quarkus application integrated with Dapr, configure DevServices to enable a Dapr sidecar, and use the Pub/Sub and State Management building blocks through practical examples.</p> <p>Below, you can find some links to documentation and sample code to help deepen the concepts presented. This post makes it clear how combining Quarkus and Dapr can boost productivity and standardize the development of distributed applications.</p>"},{"location":"2024/12/07/improve-developer-joy-and-productivity-with-quarkus-and-dapr/#references","title":"References","text":"<ul> <li>https://docs.quarkiverse.io/quarkus-dapr/dev/index.html</li> <li>https://quarkus.io/</li> <li>https://docs.dapr.io/reference/arguments-annotations-overview/</li> <li>https://docs.dapr.io/concepts/</li> </ul>"},{"location":"2024/12/07/improve-developer-joy-and-productivity-with-quarkus-and-dapr/#source-code","title":"Source Code","text":"<p>If you want to see a real code that uses Dapr, see the following repositories:</p> <ul> <li>https://github.com/mcruzdev/try-dapr</li> <li>https://github.com/mcruzdev/pizza-quarkus</li> </ul>"},{"location":"2024/12/07/improve-developer-joy-and-productivity-with-quarkus-and-dapr/#thank-you","title":"Thank you","text":"<p>That's all; thank you for reading! See you in the next post. Goodbye! \ud83d\udc4b</p>"},{"location":"archive/2024/","title":"2024","text":""},{"location":"category/quarkus/","title":"Quarkus","text":""},{"location":"category/dapr/","title":"Dapr","text":""},{"location":"category/java/","title":"Java","text":""},{"location":"category/redis/","title":"Redis","text":""},{"location":"category/event-driven/","title":"Event-Driven","text":""},{"location":"category/microservices/","title":"Microservices","text":""},{"location":"category/pattern/","title":"Pattern","text":""},{"location":"category/panache/","title":"Panache","text":""},{"location":"category/devservices/","title":"DevServices","text":""},{"location":"category/scheduler/","title":"Scheduler","text":""},{"location":"category/jnosql/","title":"JNoSQL","text":""},{"location":"category/docker/","title":"Docker","text":""},{"location":"category/testcontainers/","title":"TestContainers","text":""},{"location":"category/kind/","title":"KinD","text":""},{"location":"category/kubernetes/","title":"Kubernetes","text":""},{"location":"category/gizmo/","title":"Gizmo","text":""},{"location":"category/jandex/","title":"Jandex","text":""}]}